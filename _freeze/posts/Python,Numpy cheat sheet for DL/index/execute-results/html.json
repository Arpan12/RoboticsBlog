{
  "hash": "516718cc4a604a83ee5d02147d31b80d",
  "result": {
    "markdown": "---\ntitle: \"Python and Numpy cheat sheet for DL\"\nauthor: \"Arpan Pallar\"\ndate: \"2023-06-10\"\ncategories: [DL, Code, Python]\nimage: \"image.jpg\"\n---\n\n\n#### np.zeros\n\n| **numpy.zeros(*shape*, *dtype=[float]{.underline}*, *order=['C']{.underline}*, *\\**, *like=[None]{.underline}*)**\n| Return a new array of given shape and type, filled with zeros.\n| \n\n**Parameters:**\n\n:   \n\n    **shapeint or tuple of ints**\n\n    :   Shape of the new array, e.g., `(2, 3)` or `2`.\n\n    **dtypedata-type, optional**\n\n    :   The desired data-type for the array, e.g., [**`numpy.int8`**](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.int8 \"numpy.int8\"). Default is [**`numpy.float64`**](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.float64 \"numpy.float64\").\n\n    **order{'C', 'F'}, optional, default: 'C'**\n\n    :   Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.\n\n    **likearray_like, optional**\n\n    :   Reference object to allow the creation of arrays which are not NumPy arrays. If an array-like passed in as `like` supports the `__array_function__` protocol, the result will be defined by it. In this case, it ensures the creation of an array object compatible with that passed in via this argument.\n\n```         \nnp.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])  # default is numpy.float64\n```\n\n```         \n>>>np.zeros((5,), dtype=int) #if you want to create a 1D array\narray([0, 0, 0, 0, 0])\n\n>>>np.zeros((5,1))\narray([[0.],\n       [0.],\n       [0.],\n       [0.],\n       [0.]])\n       \n       \n>>>s = (2,2)\n>>>np.zeros(s)\narray([[ 0.,  0.],\n       [ 0.,  0.]]\n       \n#Multi-dim array \n>> np.zeros((4,3,2))  #a row of 2 element repeated 3 times-> 3*2 array->repeated 4 times to give 4*3*2 array\n\narray([[[0., 0.],\n        [0., 0.],\n        [0., 0.]],\n\n       [[0., 0.],\n        [0., 0.],\n        [0., 0.]],\n\n       [[0., 0.],\n        [0., 0.],\n        [0., 0.]],\n\n       [[0., 0.],\n        [0., 0.],\n        [0., 0.]]])\n```\n\n#### Get and Set Numpy Array Value\n\n```         \nx = np.zeros((4,3,2))\n#just like you would do in Python list or C array\nx[3][1][0]=1\n```\n\n#### np.zeros_like\n\n**numpy.zeros_like(*a*, *dtype=[None]{.underline}*, *order=['K']{.underline}*, *subok=[True]{.underline}*, *shape=[None]{.underline}*)[\\[source\\]](https://github.com/numpy/numpy/blob/v1.24.0/numpy/core/numeric.py#L77-L143)**\n\n:   Return an array of zeros with the same shape and type as a given array.\n\n    **Parameters:**\n\n    :   \n\n        **aarray_like**\n\n        :   The shape and data-type of *a* define these same attributes of the returned array.\n\n        **dtypedata-type, optional**\n\n        :   Overrides the data type of the result.\n\n```         \n>>>x = np.arange(6)}\n>>>x = x.reshape((2, 3))\n>>>x\narray([[0, 1, 2],\n       [3, 4, 5]])\n>>>np.zeros_like(x)\narray([[0, 0, 0],\n       [0, 0, 0]])\n```\n\nnp.ones:\n\nnp.eye:\n\nreversed(range(n))\n\nnp.random.shuffle\n\n#### np.arange\n\n```\n>>>np.arange(6) \\# 1D array\narray([0, 1, 2, 3, 4, 5])\n\n```         \n\n#### np.reshape\n\n**numpy.reshape(*a*, *newshape*, *order=['C']{.underline}*)**\n\n:   Gives a new shape to an array without changing its data.\n\n**Parameters:**\n\n:   \n\n    **aarray_like**\n\n    :   Array to be reshaped.\n\n    **newshapeint or tuple of ints**\n\n    :   The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.\n\n```{>>>a = np.arange(6).reshape((3, 2))}\n>>>a       \n#notice it is row wise. It makes easier to visualize if you put all the element \n#in 1D row array. Then take start row wise rearrangement  \n\narray([[0, 1],\n       [2, 3],\n       [4, 5]])\n\n>>>np.reshape(a, (2, 3)) # C-like index ordering\narray([[0, 1, 2],\n       [3, 4, 5]])\n       \n#there can be one -1 index meaning its dimention are infered from number of elements and remaining specified shape\n>>>np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n```\n\nnp array slices\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}